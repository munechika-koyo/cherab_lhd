from collections import defaultdict
import numpy as np
from matplotlib import pyplot as plt
from mpl_toolkits.axes_grid1.axes_grid import ImageGrid
from matplotlib.ticker import MultipleLocator, AutoMinorLocator, AutoLocator, ScalarFormatter

from cherab.lhd.emitter.E3E import Discrete3DMesh, EMC3Mask
from cherab.lhd.tools import sample3d_rz

from multiprocessing import Process, Manager

# Const.
RMIN = 2.0  # [m]
RMAX = 5.5
ZMIN = -1.6
ZMAX = 1.6


def show_LHD_rz_plane(func, phi_degs=[0.0], nrows_ncols=None, resolution=5.0e-3, masked_func=None, clabel=None, cmap="plasma", **kwargs):
    """
    show E3E discretized data function in r - z plane

    Parameters
    ----------
    func : callable
        callable object
    phi_degs : list of float, optional
        toroidal angles, by default [0.0]
    nrows_ncols : (int, int)
        Number of rows and columns in the grid.
        This is automatically rearranged by the length of `.phi_degs`.
    resolution : float, optional
        sampling resolution, by default 5.0e-3
    masked_func : callable, optional
        if given, masking sampled values by index wrapped by EMC3Mask, by default None
    clabel : str, optional
        colorbar label, by default None
    cmap: str, optional
        colorbar map, by default "plasma"
    **kwargs : :obj:`~mpl_toolkits.axes_grid1.axes_grid.ImageGrid` properties, optional
        *kwargs* are used to specify properties, by default axes_pad=0.0, label_mode="L", cbar_mode="single".

    Returns
    -------
    tuple of :obj:`~matplotlib.figure.Figure`, :obj:`~mpl_toolkits.axes_grid1.axes_grid.ImageGrid`
    """

    if nrows_ncols:
        if not (isinstance(nrows_ncols, tuple) and len(nrows_ncols) == 2):
            raise TypeError("nrows_ncols must be list containing two elements.")
        if nrows_ncols[0] * nrows_ncols[1] < len(phi_degs):
            raise ValueError("nrows_ncols must have numbers over length of phi_degs.")
    else:
        nrows_ncols = (1, len(phi_degs))

    if masked_func:
        if not isinstance(masked_func, Discrete3DMesh):
            raise TypeError("masked_func must be a callable generated by EMC3Mask")
        else:
            masked_func = EMC3Mask(masked_func)

    # sampling rate
    nr = int(round((RMAX - RMIN) / resolution))
    nz = int(round((ZMAX - ZMIN) / resolution))

    fig = plt.figure()

    # set default ImageGrid parameters
    grid_params = defaultdict(**kwargs)
    grid_params.setdefault("axes_pad", 0.0)
    grid_params.setdefault("label_mode", "L")
    grid_params.setdefault("cbar_mode", "single")

    grids = ImageGrid(fig, 111, nrows_ncols, **grid_params)

    # parallelized sampling
    manager = Manager()
    profiles_dict = manager.dict()

    for i, phi_deg in enumerate(phi_degs):
        process = Process(
            target=_sampling_funcion,
            kwargs={
                "phi_deg": phi_deg,
                "func": func,
                "masked_func": masked_func,
                "nr": nr,
                "nz": nz,
                "profiles_dict": profiles_dict,
                "process_index": i
            }
        )
        process.start()

    process.join()

    # maximum value of all profiles
    max_value = np.max([profile.max() for profile in profiles_dict.values()])

    # r, z grids
    r_pts = np.linspace(RMIN, RMAX, nr)
    z_pts = np.linspace(ZMIN, ZMAX, nz)

    for i, (ax, phi_deg) in enumerate(zip(grids, phi_degs)):

        # mapping
        mappable = ax.pcolormesh(r_pts, z_pts, profiles_dict[i], cmap=cmap, shading="auto", vmin=0, vmax=max_value)

        # annotation of toroidal angle
        ax.text(
            RMIN + 0.1,
            ZMAX - 0.1,
            f"$\\phi=${phi_deg:.1f}$^\\circ$",
            fontsize=10,
            va="top",
            bbox=dict(boxstyle="square, pad=0.1", edgecolor="k", facecolor="w", linewidth=0.8),
        )

        # set each axis
        ax.set_xlabel("R[m]")
        ax.xaxis.set_minor_locator(MultipleLocator(0.1))
        ax.yaxis.set_minor_locator(MultipleLocator(0.1))
        ax.xaxis.set_major_formatter("{x:.1f}")
        ax.yaxis.set_major_formatter("{x:.1f}")
        ax.tick_params(direction="in", labelsize=10, which="both", top=True, right=True)

    # set colorbar
    cbar = plt.colorbar(mappable, grids.cbar_axes[0])
    cbar.set_label(clabel)
    cbar.ax.yaxis.set_major_locator(AutoLocator())
    cbar.ax.yaxis.set_minor_locator(AutoMinorLocator())
    fmt = ScalarFormatter(useMathText=True)
    fmt.set_powerlimits((0, 0))
    cbar.ax.yaxis.set_major_formatter(fmt)
    cbar_text = cbar.ax.yaxis.get_offset_text()
    x, y = cbar_text.get_position()
    cbar_text.set_position((x * 3.0, y))

    # set yaxis label
    nrow, ncol = grids.get_geometry()
    for i in range(nrow):
        grids[i * ncol].set_ylabel("Z[m]")

    return (fig, grids)


def _sampling_funcion(phi_deg, func, masked_func, nr, nz, profiles_dict, process_index):
    """excute multiple sampling in phi_degs
    This is defined for multiprocessing
    """

    # sampling
    _, _, fvar = sample3d_rz(func, (RMIN, RMAX, nr), (ZMIN, ZMAX, nz), phi_deg)

    # sampling masked function
    if masked_func:
        _, _, mask = sample3d_rz(masked_func, (RMIN, RMAX, nr), (ZMIN, ZMAX, nz), phi_deg)
    else:
        mask = np.ones_like(fvar, dtype=np.bool8)

    # masking
    profile = np.transpose(np.ma.masked_array(fvar, mask=np.logical_not(mask)))

    # store
    profiles_dict[process_index] = profile
