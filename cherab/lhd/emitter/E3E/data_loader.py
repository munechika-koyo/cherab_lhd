# This module was made to parse and load E3E each raw data
import os
import re
import numpy as np

DEFAULT_DATA_REPOSITORY = os.path.join(os.path.dirname(__file__), "data")


class DataLoader:
    """EMC3-EIRENE data loader
    This class offers methods to read raw data generated by EMC3-EIRENE.

    Parameters
    ----------
    path : str
        path to directory where raw data (CELL_GEO, DENSITY, etc...) are stored

    Example
    -------
    .. prompt:: python auto

        >>> from cherab.lhd.emitter.E3E import DataLoader
        >>> loader = DataLoader()
        >>> loader.radiation()
        array([0.000e+00, 0.000e+00, 0.000e+00, ..., 9.450e-33, 4.922e-33,
               2.659e-33])
        >>>
        >>> loader.density_ions()
        {'H+': array([3.7917e+19, 3.5602e+19, 3.7012e+19, ..., 4.3626e+16, 1.5922e+16,
                      1.1246e+16]),
         'C1+': array([0.0000e+00, 0.0000e+00, 0.0000e+00, ..., 6.6688e+16, 6.2780e+16,
                       5.0213e+16]), ...
        }
    """

    def __init__(self, path=None) -> None:

        # path to E3E data files
        self.path = path or DEFAULT_DATA_REPOSITORY

        # compiled regular expressions for pattern matching
        self.pattern_index = re.compile(r"\s+\d+\n")
        self.pattern_value = re.compile(r" -?\d\.\d{4}E[+-]\d{2}")  # e.g.) -1.2345E+12

        # load number of plasma cells
        self.num_total, self.num_plasma, self.num_plasma_vac = _num_cells(self.path)

    def radiation(self) -> np.ndarray:
        """Load plasma radation data

        Returns
        -------
        numpy.ndarray
            1D radiation data [W/m^3]
        """
        with open(os.path.join(self.path, "RADIATION_1"), "r") as f:
            _ = f.readline()  # skip first row
            radiation = f.read()
        # extract values
        radiation = re.findall(self.pattern_value, radiation)
        radiation = np.asarray_chkfinite(radiation, dtype=np.float64) * 1.0e6  # [W/cm^3] -> [W/m^3]

        # validation
        if radiation.size != self.num_plasma:
            raise ValueError(
                f"The size of radation data ({radiation.size}) "
                f"must be same as the number of plasma cells ({self.num_plasma})"
            )

        # make negative velues positive
        radiation[radiation < 0] = 0.0

        return radiation

    def impurity_radiation(self) -> np.ndarray:
        """Load impurity radation data.

        Returns
        -------
        numpy.ndarray
            1D impurity radiation data [W/m^3].
            negative values are made positive.
        """
        with open(os.path.join(self.path, "IMP_RADIATION"), "r") as f:
            radiation = f.read()
        # extract values
        radiation = re.findall(self.pattern_value, radiation)
        radiation = np.asarray_chkfinite(radiation, dtype=np.float64) * 1.0e6  # [W/cm^3] -> [W/m^3]

        # validation
        if radiation.size != self.num_plasma:
            raise ValueError(
                f"The size of impurity radation data ({radiation.size}) "
                f"must be same as the number of plasma cells ({self.num_plasma})"
            )

        # make negative values positive
        radiation = np.negative(radiation)

        # make negative values zero
        radiation[radiation < 0] = 0.0

        return radiation

    def density_electron(self) -> np.ndarray:
        """Load electron density data which is same as H+ ones

        Returns
        -------
        numpy.ndarray
            1D electron density data [1/m^3]
        """
        with open(os.path.join(self.path, "DENSITY"), "r") as f:
            density = f.read()

        # divide values by index
        density = re.split(self.pattern_index, density)

        density = (
            np.asarray_chkfinite(re.findall(self.pattern_value, density[1]), dtype=np.float64) * 1.0e6
        )  # [1/cc] -> [1/m^3]

        # validation
        if density.size != self.num_plasma:
            raise ValueError(
                f"The size of electron density data ({density.size}) "
                f"must be same as the number of plasma cells ({self.num_plasma})"
            )

        return density

    def density_ions(self) -> dict:
        """Load ions density data.
        the list of species state is:
        H+, C1+, C2+,..., C+6, Ne1+,..., Ne10+.
        The total number is 17.

        Returns
        -------
        dict{str: numpy.ndarray}
            key is label of ion and value is density data [1/m^3]
        """
        state_list = ["H+"] + [f"C{i}+" for i in range(1, 7)] + [f"Ne{i}+" for i in range(1, 11)]
        density_ions = {state: None for state in state_list}
        with open(os.path.join(self.path, "DENSITY"), "r") as f:
            densities = f.read()

        # divide values by index
        densities = re.split(self.pattern_index, densities)

        # mapping density values into each state lavel
        for ion, density in zip(density_ions.keys(), densities[1:]):
            density_ions[ion] = (
                np.asarray_chkfinite(re.findall(self.pattern_value, density), dtype=np.float64) * 1.0e6
            )  # [1/cc] -> [1/m^3]
            # validation
            if density_ions[ion].size != self.num_plasma:
                raise ValueError(
                    f"The size of {ion} density data ({density_ions[ion].size}) "
                    f"must be same as the number of plasma cells ({self.num_plasma})"
                )

        return density_ions

    def density_neutrals(self) -> dict:
        """Load neutral particles density data.
        the list of species state is:
        H, H2, C, Ne.

        Returns
        -------
        dict{str: numpy.ndarray}
            key is label of species and value is density data [1/m^3]
        """
        density_neutral = {atom: None for atom in ["H", "H2", "C", "Ne"]}
        files = ["DENSITY_A", "DENSITY_M", "IMPURITY_NEUTRAL_2", "IMPURITY_NEUTRAL_3"]

        for file, atom in zip(files, density_neutral.keys()):

            with open(os.path.join(self.path, file), "r") as f:
                density = f.read()

            density_neutral[atom] = (
                np.asarray_chkfinite(re.findall(self.pattern_value, density), dtype=np.float64) * 1.0e6
            )  # [1/cc] -> [1/m^3]

            # validation
            if density_neutral[atom].size != self.num_plasma_vac and density_neutral[atom].size != self.num_plasma:
                raise ValueError(
                    f"The size of {atom} density data ({density_neutral[atom].size}) "
                    f"must be same as the number of plasma ({self.num_plasma_vac}) with vacuume cells"
                )

        return density_neutral

    def temperature_electron_ion(self) -> tuple:
        """Load electron and ion (H+) temperature

        Returns
        -------
        tuple(numpy.ndarray)
            electron and ion temperature data [eV]
        """
        with open(os.path.join(self.path, "TE_TI"), "r") as f:
            temp = f.read().split()

        temp_e = np.asarray_chkfinite(temp[: self.num_plasma], dtype=np.float64)
        temp_ion = np.asarray_chkfinite(temp[self.num_plasma :], dtype=np.float64)

        # validation
        if temp_ion.size != self.num_plasma:
            raise ValueError(
                f"The size of ion temperature data ({temp_ion.size}) "
                f"must be same as the number of plasma cells ({self.num_plasma})"
            )

        return (temp_e, temp_ion)

    def temperature_neutrals(self) -> dict:
        """Load neutral particles temperature data.
        the list of species state is:
        H, H2

        Returns
        -------
        dict{str: numpy.ndarray}
            key is label of species and value is density data [eV]
        """
        temperature_neutral = {atom: None for atom in ["H", "H2"]}
        files = ["TEMPERATURE_A", "TEMPERATURE_M"]

        for file, atom in zip(files, temperature_neutral.keys()):

            with open(os.path.join(self.path, file), "r") as f:
                density = f.read()

            temperature_neutral[atom] = np.asarray_chkfinite(re.findall(self.pattern_value, density), dtype=np.float64)

            # validation
            if temperature_neutral[atom].size != self.num_plasma_vac:
                raise ValueError(
                    f"The size of {atom} electron data ({temperature_neutral[atom].size}) "
                    f"must be same as the number of plasma with vacuume cells ({self.num_plasma_vac})"
                )

        return temperature_neutral


def _num_cells(path) -> tuple:
    """Read the number of 3 type cells from .data/CELL_GEO file.

    Parameters
    ----------
    path : str
        path to CELL_GEO directory

    Returns
    -------
    tuple(int)
        number of total cells
        number of plasma cells
        number of plasma with vacuume cells
    """
    with open(os.path.join(path, "CELL_GEO"), "r") as f:
        try:
            num_total, num_plasma, num_plasma_vac = list(map(int, f.readline().split()))
        except Exception:
            raise ("Reading the number of cells didn't work well.")

    return (num_total, num_plasma, num_plasma_vac)


if __name__ == "__main__":
    # debug
    loader = DataLoader()
    ne = loader.density_electron()
    nn = loader.density_neutrals()
