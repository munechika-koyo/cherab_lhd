import os
import json
import numpy as np

from raysect.core import Node
from raysect.core.math import Point3D, Vector3D, translate, rotate_basis, rotate_z
from raysect.optical.observer import TargettedCCDArray

from cherab.tools.observers import BolometerSlit, BolometerFoil


_DATA_DIR_PATH = os.path.join(os.path.dirname(__file__), "data")


# ----------------------- #
# IRVB observer class
# ----------------------- #
class BolometerIRVB(Node):
    """Bolometer IRVB class inherited from Node.
    This instance stands for IRVB camera comprised of slit and foil instances.
    A slit and foil are generated by BolometerSlit and TargettedCCDArray classes, respectively.
    IRVB's configurations are automatically loaded from .json file stored in bolometer/data directry.

    Parameters
    ----------
    parent : Node
        The parent node of this camera in the scenegraph, often an optical World object.
    name : str, optional
        IRVB name. "IB65U" & "IB65L" are available so far, by default "IB65U"
    """

    def __init__(self, parent=None, name="IB65U") -> None:
        # select IRVB
        if name not in ["IB65U", "IB65L"]:
            raise ValueError("name must be selected in 'IB65U' or 'IB65L'")

        # load IRVB setting from json file
        with open(os.path.join(_DATA_DIR_PATH, name + ".json"), "r") as f:
            irvb = json.load(f)

        super().__init__(parent=parent, name=irvb["name"] + "-BolometerCamera")

        # slit & foil corners
        slit_corners = np.asarray_chkfinite(irvb["slit"])
        foil_corners = np.asarray_chkfinite(irvb["foil"])

        slit_corners = [Point3D(*slit_corners[i, :]) for i in range(4)]
        foil_corners = [Point3D(*foil_corners[i, :]) for i in range(4)]

        # -------------- IRVB Slit ----------------------- #
        slit_geometry = self._centre_basis_and_dimensions(slit_corners)
        centre, basis_x, basis_y, width, height = slit_geometry
        self._slit = BolometerSlit(
            slit_id=irvb["name"] + "-slit",
            centre_point=centre,
            basis_x=basis_x,
            dx=width,
            basis_y=basis_y,
            dy=height,
            parent=self,
        )

        # --------------- IRVB Foil ---------------------- #
        foil_geometry = self._centre_basis_and_dimensions(foil_corners)
        foil_centre, basis_x, basis_y, width, _ = foil_geometry
        foil_normal = basis_x.cross(basis_y)
        transform = translate(foil_centre.x, foil_centre.y, foil_centre.z) * rotate_basis(foil_normal, basis_y)
        self._foil = TargettedCCDArray(
            [self.slit.target],
            pixels=irvb["pixels"],
            width=width,
            targetted_path_prob=0.99,
            transform=transform,
            parent=self,
            name=irvb["name"] + "-foil",
        )

        # ------------ Bolometer foils array --------------- #
        nx, ny = self.pixels
        pixel_pitch = self.foil.width / nx
        foil_hight = pixel_pitch * ny
        # Foil pixels are defined in the foil's local coordinate system
        foil_bottom_left = foil_centre - basis_x * self.foil.width * 0.5 - basis_y * foil_hight * 0.5
        # Point3D(-self.foil.width * 0.5, -foil_hight * 0.5, 0)
        pixels = []
        for x in range(nx):
            pixel_column = []
            for y in range(ny):
                pixel_centre = foil_bottom_left + (x + 0.5) * basis_x * pixel_pitch + (y + 0.5) * basis_y * pixel_pitch
                pixel = BolometerFoil(
                    detector_id="IRVB pixel ({},{})".format(x + 1, y + 1),
                    centre_point=pixel_centre,
                    basis_x=basis_x,
                    dx=pixel_pitch,
                    basis_y=basis_y,
                    dy=pixel_pitch,
                    slit=self._slit,
                    accumulate=False,
                    parent=self,
                )
                pixel_column.append(pixel)
            pixels.append(pixel_column)
        self._pixels_as_foils = np.asarray(pixels, dtype="object")

        # rotate bolometer toroidally
        self.transform = rotate_z(irvb["rotate"])

        # foil center
        self._foil_centre_pos = foil_centre.transform(self.to_root())

        # foil corners
        self._foil_corners = [foil_corners[i].transform(self.to_root()) for i in range(4)]

        # camera direction
        self._cam_direction = self._foil_centre_pos.vector_to(self.cam_pos).normalise()

        # camera roll
        yaxis_local = Vector3D(0, 1, 0).transform(rotate_basis(self.cam_direction, Vector3D(0, 1, 0)))
        self._cam_roll = yaxis_local.angle(basis_y.transform(self.to_root()))

    def __repr__(self):
        """
        Returns a string representation of this BolometerIRVB object.
        """
        return "<BolometerIRVB - " + self.name + ">"

    @property
    def pixels_as_foils(self):
        """
        Returns 2D-array containing BolometerFoil instances
        Each foil instance is defined in IRVB foil pixels

        Returns
        -------
        ndarray.numpy
            elements are BolometerFoil instances.
        """
        return self._pixels_as_foils

    @property
    def slit(self):
        """
        Returns a BolometerSlit instance.
        """
        return self._slit

    @property
    def foil(self):
        """
        Returns a TargettedCCDArray instance as foil.
        """
        return self._foil

    @property
    def pixels(self):
        """foil pixels

        Returns
        -------
        tuple
        """
        return self.foil.pixels

    @pixels.setter
    def pixels(self, value):
        """foil pixels setter

        Parameters
        ----------
        value : tuple
            foil pixels (x, y)
        """
        self.foil.pixels = value

    @property
    def cam_pos(self):
        """
        Returns IRVB slit centre position in world coords.

        Returns
        -------
        Point3D
        """
        return self.slit.centre_point

    @property
    def cam_direction(self):
        """
        Returns IRVB direction vector from foil cntre to slit centre

        Returns
        -------
        Vector3D
        """
        return self._cam_direction

    @property
    def foil_centre_pos(self):
        """
        Returns Foil centre position in the world coords.

        Returns
        -------
        Point3D
        """
        return self._foil_centre_pos

    @property
    def foil_corners(self):
        """
        Returns Foil corners position in the world coords.

        Returns
        -------
        list
            containing four Point3D instances
        """
        return self._foil_corners

    @property
    def focal_length(self):
        """
        Returns Distance from slit to foil centre.

        Returns
        -------
        float
            Distance between foil centre and slit centre
        """
        return self.slit.centre_point.distance_to(self.foil_centre_pos)

    @property
    def cam_roll(self):
        """
        Returns Camera roll. This is the angle between the lab +Z axis and the camera’s “view up” direction.

        Returns
        ------
        float
            roll angel in unit degree
        """
        return self._cam_roll

    def observe(self) -> None:
        """
        Excutes a foil's observe method.
        """
        self.foil.observe()

    def _centre_basis_and_dimensions(self, corners):
        """Calculate the centre point, basis vectors, width and height given 4 corners."""
        centre = Point3D(
            np.mean([corner.x for corner in corners]),
            np.mean([corner.y for corner in corners]),
            np.mean([corner.z for corner in corners]),
        )
        basis_x = corners[0].vector_to(corners[1]).normalise()
        basis_y = corners[1].vector_to(corners[2]).normalise()
        width = corners[0].distance_to(corners[1])
        height = corners[1].distance_to(corners[2])
        return centre, basis_x, basis_y, width, height


if __name__ == "__main__":
    from raysect.core import print_scenegraph
    from raysect.optical import World

    world = World()
    irvb = BolometerIRVB(world)
    print_scenegraph(world)
    # irvb.observe()
    print(irvb)
