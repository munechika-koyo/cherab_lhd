"""Module defining the IRVB Camera class."""

from __future__ import annotations

from typing import Any

import numpy as np
from numpy import ndarray
from plotly import graph_objects as go
from raysect.core import Node, Primitive
from raysect.core.math import AffineMatrix3D, Point3D, Vector3D, translate
from raysect.optical import Ray, World
from raysect.optical.loggingray import LoggingRay
from raysect.optical.material import AbsorbingSurface
from raysect.optical.observer import TargetedCCDArray
from raysect.primitive import Box

from cherab.tools.observers import BolometerFoil, BolometerSlit

__all__ = ["IRVBCamera"]


XAXIS = Vector3D(1, 0, 0)
YAXIS = Vector3D(0, 1, 0)
ZAXIS = Vector3D(0, 0, 1)
ORIGIN = Point3D(0, 0, 0)


class IRVBCamera(Node):
    """InfraRed imaging Video Bolometer class.

    This instance stands for IRVB camera comprised of slit and foil instances.
    A slit and foil are generated by :obj:`~cherab.tools.observers.bolometry.BolometerSlit` and
    :obj:`~raysect.optical.observer.imaging.targeted_ccd.TargetedCCDArray` classes, respectively.

    Parameters
    ----------
    camera_geometry : :obj:`~raysect.core.scenegraph.primitive.Primitive`
        A Raysect primitive to supply as the box/aperture geometry.
    parent : :obj:`~raysect.core.scenegraph.node.Node`
        The parent node of this camera in the scenegraph, often an optical World object.
    transform : :obj:`~raysect.core.math.affinematrix.AffineMatrix3D`
        The relative coordinate transform of this bolometer camera relative to the parent.
    name : str, optional
        IRVB name.

    Examples
    --------
    >>> from raysect.optical import World
    >>> from cherab.lhd.observer import IRVBCamera
    >>>
    >>> world = World()
    >>> camera = IRVBCamera(name="MyBolometer", parent=world)
    """

    def __init__(
        self,
        camera_geometry: Primitive | None = None,
        parent: Node | None = None,
        transform: AffineMatrix3D | None = None,
        name: str = "",
    ) -> None:
        super().__init__(parent=parent, transform=transform, name=name)

        self._foil_detector: TargetedCCDArray | None = None
        self._slit: BolometerSlit | None = None

        if camera_geometry is not None:
            if not isinstance(camera_geometry, Primitive):
                raise TypeError("camera_geometry must be a primitive")
            camera_geometry.parent = self
        self._camera_geometry = camera_geometry

    def __repr__(self) -> str:
        return f"IRVBCamera(name={self.name})"

    @property
    def slit(self) -> BolometerSlit:
        """`~cherab.tools.observers.bolometry.BolometerSlit` instances."""
        return self._slit

    @slit.setter
    def slit(self, value: BolometerSlit):
        if not isinstance(value, BolometerSlit):
            raise TypeError("The slit attribute must be a BolometerSlit instance.")

        if value.parent != self:
            value.parent = self

        self._slit = value

    @property
    def foil_detector(self) -> TargetedCCDArray:
        """A `~raysect.optical.observer.imaging.targeted_ccd.TargetedCCDArray` instance."""
        return self._foil_detector

    @foil_detector.setter
    def foil_detector(self, value: TargetedCCDArray):
        if not isinstance(value, TargetedCCDArray):
            raise TypeError("The foil_detector attribute must be a TargetedCCDArray instance.")

        if value.parent != self:
            value.parent = self

        self._foil_detector = value

    @property
    def pixels_as_foils(self) -> ndarray:
        """Regard each pixel as a bolometer foil.

        The element is a `~cherab.tools.observers.bolometry.BolometerFoil` instance.

        Returns
        -------
        `~numpy.ndarray`
            Array of `~cherab.tools.observers.bolometry.BolometerFoil` object instances.

        Examples
        --------
        >>> from cherab.lhd.observer.boloneter import load_irvb
        >>> irvb = load_irvb()
        >>> irvb.pixels_as_foils
        array([[<BolometerFoil - IRVB pixel (1,1)>,
                <BolometerFoil - IRVB pixel (1,2)>,
                ...
                <BolometerFoil - IRVB pixel (26,20)>]], dtype=object)
        """
        nx, ny = self.foil_detector.pixels
        width = self.foil_detector.width
        pixel_pitch = width / nx
        height = pixel_pitch * ny

        # Foil pixels are defined in the foil's local coordinate system
        foil_upper_right = Point3D(width * 0.5, height * 0.5, 0)
        pixels_array = np.empty((nx, ny), dtype="object")
        for x, y in np.ndindex(nx, ny):
            pixel_centre = (
                foil_upper_right - (x + 0.5) * XAXIS * pixel_pitch - (y + 0.5) * YAXIS * pixel_pitch
            )
            pixel = BolometerFoil(
                detector_id="IRVB pixel ({},{})".format(x + 1, y + 1),
                centre_point=pixel_centre,
                basis_x=XAXIS,
                basis_y=YAXIS,
                dx=pixel_pitch,
                dy=pixel_pitch,
                slit=self._slit,
                accumulate=False,
                parent=self.foil_detector,
            )
            pixels_array[x, y] = pixel
        return pixels_array

    @property
    def sightline_rays(self) -> ndarray:
        """Array containing sightline rays `~raysect.optical.Ray`.

        Each ray starts from the centre of corresponding pixel and passes through the centre of the
        slit.
        """
        return np.asarray(
            [
                [
                    Ray(
                        pixel.centre_point,
                        pixel.centre_point.vector_to(self._slit.centre_point),
                    )
                    for pixel in pixel_column
                ]
                for pixel_column in self.pixels_as_foils
            ],
            dtype="object",
        )

    def observe(self) -> None:
        """Take an observation with this camera.

        Call `observe()` on a foil detector
        `~raysect.optical.observer.imaging.targeted_ccd.TargetedCCDArray.observe` method.
        """

        self.foil_detector.observe()

    def plot_bolometer_geometry(
        self,
        fig: go.Figure | None = None,
        plot_pixel_rays: dict[str, Any] | None = None,
        show_foil_xy_axes: bool = True,
    ):
        """3D plotting of bolometer geometry using `plotly`.

        This method plots the slit, foil, camera box, and optionally pixel rays.

        Parameters
        ----------
        fig : `~plotly.graph_objs.Figure`, optional
            Figure object created by plotly, by default `plotly.graph_objs.Figure` if fig is None.
        plot_pixel_rays : dict, optional
            Properties of plotting rays, by default None.
            If the user want to use it, set any key and value, by default
            ``{"pixel": (0, 0), "num_rays": 50, "terminate": 30e-2}`` is applied.
            ``"pixel"`` is the specific pixel where rays are triggered, ``"num_rays"`` is the number
            of rays triggered, and ``"terminate"`` is the distance between foil and the board which
            terminates triggered rays in units of meter. If ``"terminate`` is 0, no terminating
            board is set.
        show_foil_xy_axes : bool, optional
            Whether or not to show the local foil x, y axis, by default True.

        Returns
        -------
        `~plotly.graph_objs.Figure`
            Figure objects include some traces.
        """
        from raysect.primitive.csg import Subtract

        if fig is not None:
            if not isinstance(fig, go.Figure):
                raise TypeError("The fig argument must be of type plotly.graph_objs.Figure")
        else:
            fig = go.Figure()

        # Create scene graph temporally
        world = World()
        prev_parent = self.parent
        self.parent = world

        # target slit
        corners = [
            self.slit.centre_point
            - 0.5 * (+self.slit.dx * self.slit.basis_x + self.slit.dy * self.slit.basis_y),
            self.slit.centre_point
            - 0.5 * (-self.slit.dx * self.slit.basis_x + self.slit.dy * self.slit.basis_y),
            self.slit.centre_point
            - 0.5 * (-self.slit.dx * self.slit.basis_x - self.slit.dy * self.slit.basis_y),
            self.slit.centre_point
            - 0.5 * (+self.slit.dx * self.slit.basis_x - self.slit.dy * self.slit.basis_y),
        ]
        corners = np.array([[*point] for point in corners])
        fig.add_trace(
            go.Mesh3d(
                x=corners[:, 0],
                y=corners[:, 1],
                z=corners[:, 2],
                opacity=0.6,
                name="Slit",
                hovertemplate=(
                    "x: %{x}<br>"
                    "y: %{y}<br>"
                    "z: %{z}<br>"
                    f"w: {self.slit.dx * 1e3:.2f} mm<br>"
                    f"h: {self.slit.dy * 1e3:.2f} mm"
                ),
            )
        )

        # foil screen
        foil_centre_point = ORIGIN.transform(self.foil_detector.to_root())
        basis_x = XAXIS.transform(self.foil_detector.to_root())
        basis_y = YAXIS.transform(self.foil_detector.to_root())
        width = self.foil_detector.width
        pixel_pitch = self.foil_detector.width / self.foil_detector.pixels[0]
        height = pixel_pitch * self.foil_detector.pixels[1]

        corners = [
            foil_centre_point - 0.5 * (+width * basis_x + height * basis_y),
            foil_centre_point - 0.5 * (-width * basis_x + height * basis_y),
            foil_centre_point - 0.5 * (-width * basis_x - height * basis_y),
            foil_centre_point - 0.5 * (+width * basis_x - height * basis_y),
        ]
        corners = np.array([[*point] for point in corners])
        fig.add_trace(
            go.Mesh3d(
                x=corners[:, 0],
                y=corners[:, 1],
                z=corners[:, 2],
                opacity=0.6,
                name="Foil",
                hovertemplate=(
                    "x: %{x}<br>"
                    "y: %{y}<br>"
                    "z: %{z}<br>"
                    f"w: {width * 1e3:.0f} mm<br>"
                    f"h: {height * 1e3:.0f} mm"
                ),
            )
        )

        # camera box
        if self._camera_geometry is not None:
            # Determine the camera box geometry
            if isinstance(self._camera_geometry, Box):
                box = self._camera_geometry
            elif isinstance(self._camera_geometry, Subtract):
                box = self._camera_geometry.primitive_a.primitive_b
            else:
                raise NotImplementedError("Unsupported camera geometry")

            xaxis = XAXIS.transform(self.to_root())
            yaxis = YAXIS.transform(self.to_root())
            zaxis = ZAXIS.transform(self.to_root())
            lower = box.lower.transform(self.to_root())
            upper = box.upper.transform(self.to_root())
            lower_to_upper = lower.vector_to(upper)
            box_width = abs(lower_to_upper.dot(xaxis))
            box_height = abs(lower_to_upper.dot(yaxis))
            box_depth = abs(lower_to_upper.dot(zaxis))
            vertices = [
                lower,
                lower + box_width * xaxis,
                lower + box_width * xaxis + box_height * yaxis,
                lower + box_height * yaxis,
                lower + box_depth * zaxis,
                lower + box_depth * zaxis + box_width * xaxis,
                upper,
                upper - box_width * xaxis,
            ]
            vertices = np.array([[*vertex] for vertex in vertices])

            fig.add_trace(
                go.Mesh3d(
                    x=vertices[:, 0],
                    y=vertices[:, 1],
                    z=vertices[:, 2],
                    i=[7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2],
                    j=[3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3],
                    k=[0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6],
                    opacity=0.2,
                    color="#7d7d7d",
                    flatshading=True,
                    name="Camera Box",
                )
            )

        # plot rays
        if plot_pixel_rays is not None:
            # set default properties
            plot_pixel_rays.setdefault("pixel", (0, 0))  # select specific pixel number
            plot_pixel_rays.setdefault("num_rays", 50)  # number of rays triggered
            plot_pixel_rays.setdefault("terminate", 30e-2)  # terminating board in front of the foil

            # color a specified pixel plane
            pixel = plot_pixel_rays["pixel"]
            UpperRight = Point3D(
                width * 0.5 - pixel[0] * pixel_pitch, height * 0.5 - pixel[1] * pixel_pitch, 0
            )
            points = [
                Point3D(*UpperRight).transform(self.foil_detector.to_root()),
                Point3D(UpperRight.x - pixel_pitch, UpperRight.y, UpperRight.z).transform(
                    self.foil_detector.to_root()
                ),
                Point3D(
                    UpperRight.x - pixel_pitch, UpperRight.y - pixel_pitch, UpperRight.z
                ).transform(self.foil_detector.to_root()),
                Point3D(UpperRight.x, UpperRight.y - pixel_pitch, UpperRight.z).transform(
                    self.foil_detector.to_root()
                ),
            ]

            corners = np.array([[*point] for point in points])
            fig.add_trace(
                go.Mesh3d(
                    x=corners[:, 0],
                    y=corners[:, 1],
                    z=corners[:, 2],
                    opacity=0.6,
                    text="Selected",
                    color="#7fff00",
                    hovertemplate=f"Pixel: {pixel[0] + 1}, {pixel[1] + 1}<extra></extra>",
                )
            )

            # set ray terminated board
            if plot_pixel_rays["terminate"] > 0:
                terminate_board = Box(
                    lower=Point3D(-1e9, -1e9, -1e-3),
                    upper=Point3D(1e9, 1e9, 0),
                    parent=self,
                    name="terminating_board",
                )
                terminate_board.material = AbsorbingSurface()
                terminate_board.transform = translate(0, 0, plot_pixel_rays["terminate"])

            # ray tracing
            ray_temp = Ray()
            rays = self.foil_detector._generate_rays(
                pixel[0], pixel[1], ray_temp, plot_pixel_rays["num_rays"]
            )
            for ray in rays:
                origin = ray[0].origin.transform(self.foil_detector.to_root())
                direction = ray[0].direction.transform(self.foil_detector.to_root())

                log_ray = LoggingRay(origin, direction)
                log_ray.trace(world)

                if len(log_ray.log) == 0:
                    continue

                hit_point = log_ray.log[-1].hit_point.transform(log_ray.log[-1].primitive.to_root())

                line = np.array([[*origin], [*hit_point]])

                fig.add_trace(
                    go.Scatter3d(
                        mode="lines",
                        x=line[:, 0],
                        y=line[:, 1],
                        z=line[:, 2],
                        line=dict(color="#FF0033", width=2),
                        name="Ray",
                        showlegend=False,
                    )
                )

            # Set terminate_board' parent to world to remove it from IRVBCamera's children nodes
            terminate_board.parent = world

        # axis vector
        if show_foil_xy_axes:
            # slit_sensor_separation = abs(
            #     foil_centre_point.vector_to(self.slit.centre_point).dot(zaxis)
            # )
            xaxis_vector = go.Scatter3d(
                x=[foil_centre_point.x, foil_centre_point.x + width * basis_x.x],
                y=[foil_centre_point.y, foil_centre_point.y + width * basis_x.y],
                z=[foil_centre_point.z, foil_centre_point.z + width * basis_x.z],
                marker=dict(color="rgb(256, 0, 0)", size=2),
                line=dict(color="rgb(256, 0, 0)"),
                showlegend=False,
                name="X Axis",
            )
            yaxis_vector = go.Scatter3d(
                x=[foil_centre_point.x, foil_centre_point.x + height * basis_y.x],
                y=[foil_centre_point.y, foil_centre_point.y + height * basis_y.y],
                z=[foil_centre_point.z, foil_centre_point.z + height * basis_y.z],
                marker=dict(color="rgb(0, 256, 0)", size=2),
                line=dict(color="rgb(0, 256, 0)"),
                showlegend=False,
                name="Y Axis",
            )
            fig.add_trace(xaxis_vector)
            fig.add_trace(yaxis_vector)

        # figure update
        fig.update_layout(
            width=500,
            height=500,
            scene_aspectmode="data",
            margin=dict(r=10, l=10, b=10, t=10),
            legend=dict(yanchor="top", y=0.99, xanchor="left", x=0.01),
        )

        # restore previous parent node
        self.parent = prev_parent

        return fig
